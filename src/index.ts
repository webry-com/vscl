export * from "./types.js";
import { parse, TSESTree } from "@typescript-eslint/typescript-estree";

/**
 * Compiles a TypeScript string expression into a string outline.
 *
 * @example
 * ```ts
 * compileTSStringExpression('`Hello ${name}`')
 * // { success: true, value: 'Hello {}' }
 * ```
 *
 * @param expression The TypeScript expression to compile into a string.
 * This can be a string literal, template literal, or any expression that results in a string
 * @param options Options to control the compilation.
 * @param options.deep If true, the function will return all possible string values that can be generated by the expression.
 * If false, it will return a single less-precise string value.
 *
 */
export function compileTSStringExpression(
  expression: string,
  { deep = false, placeholder = "{}" }: { deep?: boolean; placeholder?: string } = {},
): { success: true; value: string[] } | { success: false; error: string } {
  const ast = parse(expression, {
    loc: false,
    range: false,
    ecmaVersion: "latest",
    sourceType: "module",
  });
  const rootExpr = (ast.body[0] as TSESTree.ExpressionStatement)?.expression;
  if (!rootExpr) {
    return { success: false, error: "Expression must be a string literal" };
  }

  return {
    success: true,
    value: deep ? deepCompile(rootExpr, placeholder) : [flatCompile(rootExpr, placeholder)],
  };
}

function flatCompile<T extends TSESTree.Expression | TSESTree.PrivateIdentifier>(node: T, placeholder: string): string {
  if (!node || !node.type) {
    return placeholder;
  }

  switch (node.type) {
    case TSESTree.AST_NODE_TYPES.Literal:
      return String(node.value);
    case TSESTree.AST_NODE_TYPES.TemplateLiteral:
      let result = "",
        i = 0;
      for (const quasi of node.quasis) {
        result += quasi.value.cooked;
        if (!quasi.tail) {
          result += flatCompile(node.expressions[i++], placeholder);
        }
      }
      return result;
    case TSESTree.AST_NODE_TYPES.BinaryExpression:
      return node.operator === "+"
        ? flatCompile(node.left, placeholder) + flatCompile(node.right, placeholder)
        : placeholder;
    case TSESTree.AST_NODE_TYPES.SequenceExpression:
      return flatCompile(node.expressions[node.expressions.length - 1], placeholder);
    case TSESTree.AST_NODE_TYPES.AssignmentExpression:
      return node.operator === "=" ? flatCompile(node.right, placeholder) : placeholder;
    default:
      return placeholder;
  }
}

function deepCompile<T extends TSESTree.Expression | TSESTree.PrivateIdentifier>(
  node: T,
  placeholder: string,
): string[] {
  if (!node || !node.type) {
    return [placeholder];
  }

  switch (node.type) {
    case TSESTree.AST_NODE_TYPES.Literal:
      return [String(node.value)];
    case TSESTree.AST_NODE_TYPES.TemplateLiteral:
      let results = [""];
      let i = 0;
      for (const quasi of node.quasis) {
        results = results.map((r) => r + quasi.value.cooked);
        if (!quasi.tail) {
          results = results
            .map((r) => deepCompile(node.expressions[i], placeholder).map((compiled) => r + compiled))
            .flat();
          i++;
        }
      }
      return results;
    case TSESTree.AST_NODE_TYPES.ConditionalExpression:
      return [deepCompile(node.consequent, placeholder), deepCompile(node.alternate, placeholder)].flat();
    case TSESTree.AST_NODE_TYPES.BinaryExpression:
      return node.operator === "+"
        ? deepCompile(node.left, placeholder)
            .map((e) => deepCompile(node.right, placeholder).map((r) => e + r))
            .flat()
        : [placeholder];
    case TSESTree.AST_NODE_TYPES.SequenceExpression:
      return deepCompile(node.expressions[node.expressions.length - 1], placeholder);
    case TSESTree.AST_NODE_TYPES.LogicalExpression:
      return [deepCompile(node.left, placeholder), deepCompile(node.right, placeholder)].flat();
    case TSESTree.AST_NODE_TYPES.AssignmentExpression:
      return node.operator === "=" ? deepCompile(node.right, placeholder) : [placeholder];
    default:
      return [placeholder];
  }
}
